%! TEX root = ./main.tex

\section{Prelude}
\begin{itemize}
    \item \verb+curry :: ((a, b) -> c) -> a -> b -> c+ 
        \begin{itemize}
            \item Converts uncurried function to curried function
        \end{itemize}
     \item \verb+uncurry :: (a -> b -> c) -> (a, b) -> c+
         \begin{itemize}
             \item Converts curried function to function on tuple
         \end{itemize}
    \item \verb+fromEnum :: a -> Int+
        \begin{itemize}
            \item Gives ascii value of a char
        \end{itemize}
    \item \verb+toEnum :: Int -> a+
        \begin{itemize}
            \item Gives character of a certain ascii value
        \end{itemize}
    \item \verb+abs :: Num => a -> a+
        \begin{itemize}
            \item ABS value of number
        \end{itemize}
    \item \verb+signum :: Num => a -> a+
        \begin{itemize}
            \item Returns $-1, 0$ or $1$
        \end{itemize}
    \item \verb+foldMap :: Monoid m => (a -> m) -> t a -> m+
        \begin{itemize}
            \item Map each element of the passed list to a monoid (array of one element) and apply the function on it
            \item Example:
                \begin{itemize}
                    \item \verb+foldMap (replicate 3) [1,2,3] = [1,1,1,2,2,2,3,3,3]+
                \end{itemize}
        \end{itemize}
    \item \verb+foldr :: (a -> b -> b) -> b -> t a -> b+
    \item \verb+foldl :: (b -> a -> b) -> b -> t a -> b+
    \item \verb+elem :: Eq a => a -> t a -> Bool+
        \begin{itemize}
            \item Does element occur in list
        \end{itemize}
    \item \verb+maximum :: Ord a => t a -> a+
        \begin{itemize}
            \item Largest element of non-empty list
        \end{itemize}
    \item \verb+minimum :: Ord a => t a -> a+
        \begin{itemize}
            \item Least element of non-empty list
        \end{itemize}
    \item \verb+sum :: Num a => t a -> a+
        \begin{itemize}
            \item Sum of list
        \end{itemize}
    \item \verb+product :: Num a => t a -> a+
        \begin{itemize}
            \item Product of list
        \end{itemize}
    \item \verb+(.) :: (b -> c) -> (a -> b) -> a -> c+
        \begin{itemize}
            \item Function composition
        \end{itemize}
    \item \verb+flip :: (a -> b -> c) -> b -> a -> c+
        \begin{itemize}
            \item Takes function with two arguments and applies the arguments in switched order
        \end{itemize}
    \item \verb+($)+
        \begin{itemize}
            \item Useful to omit parentheses
            \item Example: \verb+f $ g $ h x = f ( g ( h x))+
        \end{itemize}
    \item \verb+until :: (a -> Bool) -> (a -> a) -> a -> a+
        \begin{itemize}
            \item Yields the result of applying the function until the condition hold
        \end{itemize}
    \item \verb+map :: (a -> b) -> [a] -> [b]+
    \item \verb|(++) :: [a] -> [a] -> [a]|
    \item \verb+filter :: (a -> Bool) -> [a] -> [a]+
    \item \verb+head :: [a] -> a+
        \begin{itemize}
            \item First element of the list
        \end{itemize}
    \item \verb+last :: [a] -> a+
        \begin{itemize}
            \item Last element of the list
        \end{itemize}
    \item \verb+tail :: [a] -> [a]+
        \begin{itemize}
            \item All except the first element of the list
        \end{itemize}
    \item \verb+init :: [a] -> [a]+
        \begin{itemize}
            \item All expect the last
        \end{itemize}
    \item \verb+(!!) :: [a] -> Int -> a+
        \begin{itemize}
            \item Returns the $n$-th element of a list
        \end{itemize}
    \item \verb+null :: Foldable t => t a -> Bool+
        \begin{itemize}
            \item Test whether list is empty
        \end{itemize}
    \item \verb+length :: Foldable t => t a -> Int+
        \begin{itemize}
            \item Length of list
        \end{itemize}
    \item \verb+reverse :: [a] -> [a]+
        \begin{itemize}
            \item Reverses given list
            \item Only works for finite list
        \end{itemize}
    \item \verb+and :: Foldable t => t Bool -> Bool+
        \begin{itemize}
            \item Return true iff all elements in the list are true
        \end{itemize}
    \item \verb+or :: Foldable t => t Bool -> Bool+
        \begin{itemize}
            \item Return true iff at least one element of the list is true
        \end{itemize}
    \item \verb+any :: Foldable t => (a -> Bool) -> t a -> Bool+
        \begin{itemize}
            \item Check if any element of the list satisfies the predict
        \end{itemize}
    \item \verb+all :: Foldable t => (a -> Bool) -> t a -> Bool+
        \begin{itemize}
            \item Check if all element of the list satisfies the predict
        \end{itemize}
    \item \verb+concat :: foldable t => t [a] -> [a]+
        \begin{itemize}
            \item The concatenation of all the elements of a container of lists
            \item Example: \verb+concat [[1,2,3],[4,5],[6],[] = [1,2,3,4,5,6]+
        \end{itemize}
    \item \verb+concatMap :: Foldable t => (a -> [b]) -> t a -> [b]+
        \begin{itemize}
            \item Example: \verb+concatMap (take 3) [[1..],[10..],[100..]] = [1,2,3,10,11,12,100,101,102]+
        \end{itemize}
    \item \verb+scanl :: (b -> a -> b) -> b -> [a] -> [b]+
        \begin{itemize}
            \item Similar to \verb+foldl+ but gives intermediate results
            \item Example: \verb|scanl (+) 0 [1..4] = [0,1,3,6,10]|
            \item Example: \verb|scanl (-) 100 [1..4] = [100,99,97,94,90]|
        \end{itemize}
    \item \verb+scanr :: (a -> b -> b) -> b -> [a] -> [b]+
        \begin{itemize}
            \item Similar to \verb+foldl+ but gives intermediate results
            \item Example: \verb|scanl (+) 0 [1..4] = [10,9,7,4,0]|
            \item Example: \verb|scanl (-) 100 [1..4] = [98,-97,99,-96,100]|
        \end{itemize}
    \item \verb+iterate :: (a -> a) -> a -> [a]+
        \begin{itemize}
            \item Infinitely often apply the function to the value
            \item Example: \verb|iterate (+3) 42 = [42,45,48,51,54,...]|
        \end{itemize}
    \item \verb+repeat :: a -> [a]+
        \begin{itemize}
            \item Repeat the value in an infinite list
            \item Example: \verb+repeat 0 = [0,0,0...]+
        \end{itemize}
    \item \verb+replicate :: Int -> a -> [a]+
        \begin{itemize}
            \item Create list containing $x \ n$ times
            \item Example: \verb+replicate 4 True = [True, True, True, True]+
        \end{itemize}
    \item \verb+cycle :: [a] -> [a]+
        \begin{itemize}
            \item Create infinite list from given list
            \item Example: \verb+cycle [1,2] = [1,2,1,2,1,2,...]+
        \end{itemize}
    \item \verb+take :: Int -> [a] -> [a]+
        \begin{itemize}
            \item Returns prefix of length $n$ or $xs$ if $n$ is larger than its size
            \item Example: \verb+take 3 "test" = "tes"+
        \end{itemize}
    \item \verb+drop :: Int -> [a] -> [a]+
        \begin{itemize}
            \item Returns suffix after the first $n$ elements or $[]$ if $n$ is larger than length of list
            \item Example: \verb+drop 3 "test" = "t"+
        \end{itemize}
    \item \verb+takeWhile :: (a -> Bool) -> [a] -> [a]+
        \begin{itemize}
            \item Returns longest prefix of list that all satisfy the predicate
            \item Example: \verb+takeWhile (<3) [1..5] = [1,2]+
        \end{itemize}
    \item \verb+dropWhile :: (a -> Bool) -> [a] -> [a]+
        \begin{itemize}
            \item Returns suffix after applying \verb+takewhile+
            \item Example: \verb+dropWhile (<3) [1..5] = [3,4,5]+
        \end{itemize}
    \item \verb+span :: (a -> Bool) -> [a] -> ([a], [a])+
        \begin{itemize}
            \item Tuple of \verb+takeWhile+ and \verb+dropWhile+
            \item Example: \verb+span (<3) [1..5] = ([1,2],[3,4,5])+
        \end{itemize}
    \item \verb+splitAt :: Int -> [a] -> ([a], [a])+
        \begin{itemize}
            \item Split list at $n$ (first element is $n$ long)
            \item Example: \verb+splitAt 3 "Test" = ("Tes", "t")+
        \end{itemize}
    \item \verb+zip :: [a] -> [b] -> [(a, b)]+
        \begin{itemize}
            \item Combines two list into tuple
            \item Final length is length of the shorter list
        \end{itemize}
    \item \verb+zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]+
    \item \verb+zipWith :: (a -> b -> c) -> [a] -> [b]  -> [c]+
        \begin{itemize}
            \item Example: \verb|zipWith (+) [1,2,3] [4,5,6] = [5,7,9]|
            \item \verb+zipWith3+ also exists
        \end{itemize}
    \item \verb+unzip :: (a, b) -> [a] -> [b]+
    \item \verb+unzip3 :: (a, b, c) -> [a] -> [b] -> [c]+
    \item \verb+show :: a -> String+
        \begin{itemize}
            \item Convert anything to string
        \end{itemize}
    \item \verb+read :: Read a => String -> a+
        \begin{itemize}
            \item Convert string to anything
            \item Often we need to give the type
            \item Example: \verb+read "123" :: Int = 123+
        \end{itemize}
\end{itemize}
